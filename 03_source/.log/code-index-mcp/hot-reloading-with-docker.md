# Технология "горячего" монтирования папки в Docker через `mcp.json`

Файл `.kilocode/mcp.json` является ключевым конфигурационным файлом для интеграции внешних инструментов, называемых MCP-серверами (Model-Context-Protocol), в рабочую среду. Он определяет, как запускать и взаимодействовать с этими серверами. В данном случае он настраивает запуск сервера `code-index`, который представляет собой Docker-контейнер.

Давайте детально разберем, как конфигурация в этом файле обеспечивает "горячее" монтирование.

## 1. Роль файла `.kilocode/mcp.json`

Этот файл действует как диспетчер задач для MCP-серверов. Для сервера с именем `code-index` он определяет:
-   `"command": "docker"`: Команда, которая будет выполнена для запуска сервера.
-   `"args": [...]`: Аргументы, которые передаются этой команде.

По сути, Kilo Code читает этот файл и выполняет команду `docker` с указанными аргументами для запуска контейнера `code-index`.

## 2. Команда `docker run` и её аргументы

Конфигурация преобразуется в следующую команду:

```bash
docker run -i --rm -v "<path_root_for_projects>:/workspace" code-index-mcp
```

-   `run`: Основная команда Docker для создания и запуска нового контейнера из образа.
-   `-i` (`--interactive`): Оставляет стандартный поток ввода (STDIN) открытым, что необходимо для обмена данными между Kilo Code и сервером внутри контейнера.
-   `--rm`: Указывает Docker автоматически удалить контейнер после его остановки. Это предотвращает накопление остановленных контейнеров в системе.
-   `-v ...`: Самый важный флаг для нашей задачи, отвечающий за монтирование тома (volume).

## 3. Концепция "Bind Mount" (привязка монтирования) и флаг `-v`

Флаг `-v` (или `--volume`) используется для создания связи между файловой системой хост-машины (вашего компьютера) и файловой системой внутри контейнера. Формат выглядит так:

`<путь_на_хосте>:<путь_в_контейнере>`

Это создает **"bind mount"** (привязку монтирования). В отличие от копирования файлов, bind mount создает прямое "зеркало" или ссылку на директорию хоста внутри контейнера.

**"Горячая" синхронизация** — это прямое следствие bind mount:
-   Когда вы изменяете, создаете или удаляете файл в локальной папке, эти изменения **мгновенно** и без задержек отражаются в папке `/workspace` внутри контейнера.
-   Процессы, работающие внутри контейнера (в данном случае, сервер `code-index`), видят эти изменения в реальном времени.
-   Это устраняет необходимость перезапускать или пересобирать контейнер каждый раз, когда вы вносите изменения в исходный код проекта.

## 4. Связывание путей

Конструкция `<path_root_for_projects>:/workspace` является сердцем механизма.

-   **Локальный путь**: `<path_root_for_projects>` — это заполнитель для пути к папке на вашем компьютере, содержащей проекты, которые должен анализировать `code-index`.
-   **Путь в контейнере**: `/workspace` — это точка монтирования внутри контейнера. Сервер `code-index` настроен так, чтобы искать и индексировать код именно в этой директории.

Таким образом, вы предоставляете серверу `code-index`, работающему в изолированной среде Docker, прямой и актуальный доступ к вашим локальным файлам.

### Пример шаблона .kilocode/mcp.json

```json
{
  "_comment": "The `C:/Users/Azerty/Pojcets` placeholder should be replaced with the local path to your projects. Use forward slashes (/) for the path, even on Windows. This directory is mounted into the Docker container at `/workspace`, which is the path the code-index server uses to analyze your code. The `/workspace` path is independent of the application's own directory (`/app`) defined in the Dockerfile.",
  "mcpServers": {
    "code-index": {
      "command": "docker",
      "args": [
        "run",
        "-i",
        "--rm",
        "-v",
        "C:/Users/Azerty/Pojcets:/workspace",
        "code-index-mcp"
      ]
    }
  }
}